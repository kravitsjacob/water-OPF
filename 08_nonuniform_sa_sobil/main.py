import osimport copyimport sysimport numpy as npimport pandas as pdimport pandapower as ppimport pandapower.converterimport dask.dataframe as ddimport multiprocessingfrom dask.diagnostics import ProgressBarif len(sys.argv) > 1:    pathto_data = sys.argv[1]    n_tasks = int(sys.argv[2])else:    pathto_data = 'G:\My Drive\Documents (Stored)\data_sets\water-OPF-v0.1'    n_tasks = os.cpu_count()pathto_geninfo = os.path.join(pathto_data, 'synthetic_grid', 'gen_info_match_water.csv')pathto_hnwc = os.path.join(pathto_data, 'synthetic_grid', 'historic_nonuniform_water_coefficients.csv')pathto_case = os.path.join(pathto_data, 'synthetic_grid', 'case.p')pathto_operation = os.path.join(pathto_data, 'nonuniform_sa_scenarios', 'operational_scenarios.csv')def initialize():    # Import Data    df_geninfo = pd.read_csv(pathto_geninfo)    df_operation = pd.read_csv(pathto_operation)    net = pandapower.from_pickle(pathto_case)    df_hnwc = pd.read_csv(pathto_hnwc)    # Match Pandapower indexes to Matpower    df_geninfo = matchIndex(df_geninfo, net)    return df_geninfo, df_operation, df_hnwc, netdef generate_samples(n_sample, df_hnwc):    # Sampling    replace = True  # with replacement    n_inputs_factors = len(df_hnwc['Input Factor'].unique())    fn = lambda obj: obj.loc[np.random.choice(obj.index, n_sample, replace), :]    df_sample = df_hnwc.groupby('Input Factor', as_index=False).apply(fn)    df_sample['Sample Index'] = np.tile(np.arange(0, n_sample), n_inputs_factors)    df_sample = df_sample.reset_index().pivot(columns='Input Factor', values='value', index='Sample Index')    return df_sampledef factorMultiply(ser_c_water, c_load, exogenous_labs, net, df_geninfo):    df_geninfo = df_geninfo.merge(ser_c_water, left_on=['MATPOWER Fuel', '923 Cooling Type'], right_index=True, how='left')    df_geninfo.iloc[:, -1].fillna(0, inplace=True)  # Joined column will always be last    beta_load = net.load['p_mw'].values * c_load    beta_with = (df_geninfo['Median Withdrawal Rate (Gallon/kWh)'] * df_geninfo.iloc[:,-1]).values    beta_con = (df_geninfo['Median Consumption Rate (Gallon/kWh)'] * df_geninfo.iloc[:,-1]).values    vals = np.concatenate((beta_with, beta_con, beta_load))    idxs = exogenous_labs[2:]    return pd.Series(vals, index=idxs)def getExogenous(df_sample, df_hnwc, w_with, w_con, c_load, df_geninfo, net, exogenous_labs):    # Formatting    df_unique = df_hnwc.groupby(['Fuel Type', '923 Cooling Type']).size().reset_index()[['Fuel Type', '923 Cooling Type']]    multiindex_columns = pd.MultiIndex.from_frame(df_unique)    df_sample_multi = pd.DataFrame(df_sample.values, columns=multiindex_columns)    # Multiply exogenous parameters    df_exogenous = df_sample_multi.apply(lambda row: factorMultiply(row, c_load, exogenous_labs, net, df_geninfo), axis=1)    # Combine    df_sample['Withdrawal Weight ($/Gallon)'] = w_with    df_sample['Consumption Weight ($/Gallon)'] = w_con    df_exogenous = pd.concat([df_sample, df_exogenous], axis=1)    return df_exogenousdef matchIndex(df_geninfo, net):    # Initialize    df_gen = pd.DataFrame()    df_sgen = pd.DataFrame()    df_ext_grid = pd.DataFrame()    # Generators    df_gen['MATPOWER Index'] = net.gen['bus'] + 1    df_gen['PANDAPOWER Index'] = net.gen['bus'].index.to_list()    df_gen['PANDAPOWER Bus Type'] = 'gen'    # Static Generators    df_sgen['MATPOWER Index'] = net.sgen['bus'] + 1    df_sgen['PANDAPOWER Index'] = net.sgen['bus'].index.to_list()    df_sgen['PANDAPOWER Bus Type'] = 'sgen'    # External Grid    df_ext_grid['MATPOWER Index'] = net.ext_grid['bus'] + 1    df_ext_grid['PANDAPOWER Index'] = net.ext_grid['bus'].index.to_list()    df_ext_grid['PANDAPOWER Bus Type'] = 'ext_grid'    # Combine    df_match = pd.concat([df_gen, df_sgen, df_ext_grid])    df_match.reset_index()    # Join    df_geninfo = df_geninfo.merge(df_match, on='MATPOWER Index')    return df_geninfodef waterOPF(ser_exogenous, t, results_labs, net, df_geninfo):    # Initialize    df_geninfo = df_geninfo.copy()    net = copy.deepcopy(net)  # Copy network so not changed later    obj_colnames = ['cp0_eur', 'cp1_eur_per_mw', 'cp2_eur_per_mw2']    idx_colnames = ['element', 'et']    # Create DataFrame of loads    df_load = ser_exogenous[ser_exogenous.index.str.contains('Load')].to_frame('Load (MW)')    df_load['bus'] = df_load.index.str.extract('(\d+)').astype(int).values    df_load.reset_index(inplace=True, drop=True)    # Create DataFrame of cost values    df_cost = net.poly_cost[idx_colnames + obj_colnames]    # Create DataFrame of withdrawal values    df_withdrawal = ser_exogenous[ser_exogenous.index.str.contains('Withdrawal Rate')].to_frame('Withdrawal Rate (Gallon/kWh)')    df_withdrawal['MATPOWER Index'] = df_withdrawal.index.str.extract('(\d+)').astype(int).values    df_withdrawal.reset_index(inplace=True, drop=True)    # Create DataFrame of consumption values    df_consumption = ser_exogenous[ser_exogenous.index.str.contains('Consumption Rate')].to_frame('Consumption Rate (Gallon/kWh)')    df_consumption['MATPOWER Index'] = df_consumption.index.str.extract('(\d+)').astype(int).values    df_consumption.reset_index(inplace=True, drop=True)    # Write objectives information to generator information    df_geninfo[['Cost Term ($)', 'Cost Term ($/MW)', 'Cost Term ($/MW^2)']] = df_geninfo.merge(df_cost, left_on=['PANDAPOWER Index', 'PANDAPOWER Bus Type'], right_on=idx_colnames)[obj_colnames]    df_geninfo['Withdrawal Rate (Gallon/kWh)'] = df_geninfo.merge(df_withdrawal, on='MATPOWER Index')['Withdrawal Rate (Gallon/kWh)']    df_geninfo['Consumption Rate (Gallon/kWh)'] = df_geninfo.merge(df_consumption, on='MATPOWER Index')['Consumption Rate (Gallon/kWh)']    # Convert Units    df_geninfo['Withdrawal Rate (Gallon/MW)'] = df_geninfo['Withdrawal Rate (Gallon/kWh)'] * t  # minutes * hr/minutes * kw/MW    df_geninfo['Consumption Rate (Gallon/MW)'] = df_geninfo['Consumption Rate (Gallon/kWh)'] * t  # minutes * hr/minutes * kw/MW    # Combine and weight objectives    df_geninfo['Weighted Linear Term'] = df_geninfo['Cost Term ($/MW)'] + df_geninfo['Withdrawal Rate (Gallon/MW)'] * ser_exogenous['Withdrawal Weight ($/Gallon)'] + df_geninfo['Consumption Rate (Gallon/MW)'] * ser_exogenous['Consumption Weight ($/Gallon)']    # Assign exogenous parameters to case    net.poly_cost[obj_colnames] = net.poly_cost.merge(df_geninfo, left_on=idx_colnames, right_on=['PANDAPOWER Index', 'PANDAPOWER Bus Type'])[['Cost Term ($)', 'Weighted Linear Term', 'Cost Term ($/MW^2)']]    net.load['p_mw'] = net.load.merge(df_load)['Load (MW)']    # Run DC OPF    try:        pp.rundcopp(net)        state = 'converge'    except:        state = 'not converge'    # Output Depended on State    if state is 'converge':        # Extract internal decisions (power output)        for type in ['gen', 'sgen', 'ext_grid']:            idxs = df_geninfo.index[df_geninfo['PANDAPOWER Bus Type'] == type]            df_geninfo.loc[idxs, 'Power Output (MW)'] = df_geninfo.iloc[idxs, :].merge(net['res_'+type], left_on='PANDAPOWER Index', right_index=True)['p_mw']        # Compute Capacity Ratios        df_geninfo['Ratio of Capacity'] = df_geninfo['Power Output (MW)'] / df_geninfo['MATPOWER Capacity (MW)']        # Compute Objectives        F_gen = (df_geninfo['Cost Term ($)'] + df_geninfo['Power Output (MW)'] * df_geninfo['Cost Term ($/MW)'] + df_geninfo['Power Output (MW)']**2 * df_geninfo['Cost Term ($/MW^2)']).sum()        F_with = (df_geninfo['Power Output (MW)'] * df_geninfo['Withdrawal Rate (Gallon/MW)']).sum()        F_con = (df_geninfo['Power Output (MW)'] * df_geninfo['Consumption Rate (Gallon/MW)']).sum()        F_cos = F_gen + ser_exogenous['Withdrawal Weight ($/Gallon)']*F_with + ser_exogenous['Consumption Weight ($/Gallon)']*F_con        internal_decs = df_geninfo['Ratio of Capacity'].to_list()    elif state is 'not converge':        F_cos = F_with = F_con = F_gen = np.nan        internal_decs = [np.nan]*len(df_geninfo)    return pd.Series([F_cos, F_gen, F_with, F_con] + internal_decs, index=results_labs)def MGSA_FirstOrder(Input, Output, ndomain):    '''    input: nsample * nd matrix, where nsample is the number of sample, and nd    is the input dimension    output: nsample * 1 array    ndomain: number of sub-domain the to divide a single input    This algorithm is proposed by me. Please cite the following paper if you use this code.    Li, Chenzhao, and Sankaran Mahadevan. "An efficient modularized sample-based method to estimate the first-order Sobolâ€™index." Reliability Engineering & System Safety (2016).    TODO before publishing, make sure this is just cloned from his site    '''    (nsample, nd) = np.shape(Input);    # convert the input samples into cdf domains    U = np.linspace(0.0, 1.0, num=ndomain + 1)    cdf_input = np.zeros((nsample, nd))    cdf_values = np.linspace(1.0 / nsample, 1.0, nsample)    j = 1    for i in range(nd):        IX = np.argsort(Input[:, i])        IX2 = np.argsort(IX)        cdf_input[:, i] = cdf_values[IX2]    # compute the first-order indices    VY = np.var(Output, ddof=1)    VarY_local = np.zeros((ndomain, nd))    for i in range(nd):        cdf_input_i = cdf_input[:, i]        output_i = Output        U_i = U        for j in range(ndomain):            sub = cdf_input_i < U_i[j + 1]            VarY_local[j, i] = np.var(output_i[sub], ddof=1)            inverse_sub = ~sub            cdf_input_i = cdf_input_i[inverse_sub]            output_i = output_i[inverse_sub]    index = 1.0 - np.mean(VarY_local, axis=0) / VY    return indexdef main():    # Initialize    df_geninfo, df_operation, df_hnwc, net = initialize()    exogenous_labs = ['Withdrawal Weight ($/Gallon)', 'Consumption Weight ($/Gallon)'] + \                     ('MATPOWER Generator ' + df_geninfo['MATPOWER Index'].astype(str) + ' Withdrawal Rate (Gallon/kWh)').tolist() + \                     ('MATPOWER Generator ' + df_geninfo['MATPOWER Index'].astype(str) + ' Consumption Rate (Gallon/kWh)').tolist() + \                     ('PANDAPOWER Bus ' + net.load['bus'].astype(str) + ' Load (MW)').tolist()    results_labs = ['Total Cost ($)', 'Generator Cost ($)', 'Water Withdrawal (Gallon)', 'Water Consumption (Gallon)'] + \                   ('MATPOWER Generator ' + df_geninfo['MATPOWER Index'].astype(str) + ' Ratio of Capacity').to_list()    t = 5 * 1 / 60 * 1000  # minutes * hr/minutes * kw/MW    n_sample = 1024 * (2*5+2)  # for saltelli sampling 1024    print('Success: Initialized')    # Generate Samples    df_sample = generate_samples(n_sample, df_hnwc)    factor_labs = df_sample.columns.to_list()    print('Number of Samples: ', len(df_sample))    # Loop over operational scenarios    for index, row in df_operation.iterrows():        # Define Outputs Paths        pathto_sample_output = os.path.join(pathto_data, 'nonuniform_sa_samples', row['Operational Scenario'] + ' samples.csv')        pathto_sobil_output = os.path.join(pathto_data, 'nonuniform_sa_sobol', row['Operational Scenario']+' sobol.csv')        # Apply Coefficients to Exogenous Parameters        df_exogenous = getExogenous(df_sample.copy(), df_hnwc, row['Withdrawal Weight ($/Gallon)'], row['Consumption Weight ($/Gallon)'], row['Uniform Loading Factor'], df_geninfo, net, exogenous_labs)        # Evaluate Model        ddf_exogenous = dd.from_pandas(df_exogenous, npartitions=n_tasks)        df_results = ddf_exogenous.apply(lambda row: waterOPF(row[exogenous_labs], t, results_labs, net, df_geninfo), axis=1, meta={key: 'float64' for key in results_labs}).compute(scheduler='processes')        #df_results = df_exogenous.apply(lambda row: waterOPF(row[exogenous_labs], t, results_labs, net, df_geninfo), axis=1)        df_sample_master = pd.concat([df_results, df_exogenous], axis=1)        df_sample_master.to_csv(pathto_sample_output, index=False)        print('Success: Model Run Complete')        df_sobol_results = pd.DataFrame()        for i in results_labs[0:4]:            ndomain = int(np.sqrt(df_sample_master.__len__()))            si_vals = MGSA_FirstOrder(Input=df_sample_master[factor_labs].values, Output=df_sample_master[i].values,                                      ndomain=ndomain)            df_sobol_results = df_sobol_results.append(pd.Series(si_vals, index=factor_labs).rename(i))        df_sobol_results.to_csv(pathto_sobil_output)        print('Success: Sobil Analysis')    return 0if __name__ == '__main__':    multiprocessing.freeze_support()    ProgressBar().register()    main()