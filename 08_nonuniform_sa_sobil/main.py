import osimport copyimport sysimport numpy as npimport pandas as pdimport pandapower as ppimport pandapower.converterimport dask.dataframe as ddimport multiprocessingfrom dask.diagnostics import ProgressBarfrom SALib.sample import saltelli  # Must come after dask imports due to bug in SAlibfrom SALib.analyze import sobolimport timeitif len(sys.argv) > 1:    pathto_data = sys.argv[1]    n_tasks = int(sys.argv[2])else:    pathto_data = 'G:\My Drive\Documents (Stored)\data_sets\Water_OPF_Non-Uniform_Sobil_V3_io'    n_tasks = os.cpu_count()pathto_geninfo = os.path.join(pathto_data, 'input', 'geninfo_water.csv')pathto_case = os.path.join(pathto_data, 'input', 'case.p')pathto_operation = os.path.join(pathto_data, 'input', 'operational_scenarios.csv')pathto_bounds = os.path.join(pathto_data, 'input', 'search_bounds.csv')def initialize():    # Import Data    df_geninfo = pd.read_csv(pathto_geninfo)    df_operation = pd.read_csv(pathto_operation)    df_bounds = pd.read_csv(pathto_bounds)    net = pandapower.from_pickle(pathto_case)    # Match Pandapower indexes to Matpower    df_geninfo = matchIndex(df_geninfo, net)    return df_geninfo, df_operation, df_bounds, netdef factorMultiplyOld(ser_c_water, c_load, exogenous_labs, net, df_geninfo):    beta_with = df_geninfo['Median Withdrawal Rate (Gallon/kWh)'].values    beta_con = df_geninfo['Median Consumption Rate (Gallon/kWh)'].values    beta_load = net.load['p_mw'].values    # Multiply water coefficients to each plant (Hardcoded)    start_time = timeit.default_timer()    df_water_coefficients = ser_c_water.index.str.split(expand=True).to_frame(name=['C', 'water', 'MATPOWER Fuel', '923 Cooling Type'])    df_water_coefficients['value'] = ser_c_water.values    for index, row in df_water_coefficients.iterrows():        idxs = (df_geninfo['MATPOWER Fuel'] == row['MATPOWER Fuel']) & (df_geninfo['923 Cooling Type'] == row['923 Cooling Type'])        coefficient = df_water_coefficients[(df_water_coefficients['MATPOWER Fuel'] == row['MATPOWER Fuel']) & (df_water_coefficients['923 Cooling Type'] == row['923 Cooling Type'])]['value'][0]        beta_with[idxs] = beta_with[idxs] * coefficient        beta_con[idxs] = beta_con[idxs] * coefficient    vals = np.concatenate((beta_with, beta_con, c_load * beta_load))    idxs = exogenous_labs[2:]    print(timeit.default_timer() - start_time)    return pd.Series(vals, index=idxs)def factorMultiply(ser_c_water, c_load, exogenous_labs, net, df_geninfo):    df_geninfo = df_geninfo.merge(ser_c_water, left_on=['MATPOWER Fuel', '923 Cooling Type'], right_index=True, how='left')    df_geninfo.iloc[:, -1].fillna(0, inplace=True)  # Joined column will always be last    beta_load = net.load['p_mw'].values * c_load    beta_with = (df_geninfo['Median Withdrawal Rate (Gallon/kWh)'] * df_geninfo.iloc[:,-1]).values    beta_con = (df_geninfo['Median Consumption Rate (Gallon/kWh)'] * df_geninfo.iloc[:,-1]).values    vals = np.concatenate((beta_with, beta_con, beta_load))    idxs = exogenous_labs[2:]    return pd.Series(vals, index=idxs)def getExogenous(samples, df_bounds, w_with, w_con, c_load, df_geninfo, net, exogenous_labs):    multiindex_columns = pd.MultiIndex.from_frame(df_bounds[['MATPOWER Fuel', '923 Cooling Type']])    df_sample = pd.DataFrame(samples, columns=multiindex_columns)    # Multiply exogenous parameters    df_exogenous = df_sample.apply(lambda row: factorMultiply(row, c_load, exogenous_labs, net, df_geninfo), axis=1)    # Combine    df_sample.columns = df_bounds['Input Factor']    df_sample['Withdrawal Weight ($/Gallon)'] = w_with    df_sample['Consumption Weight ($/Gallon)'] = w_con    df_sample = pd.concat([df_sample, df_exogenous], axis=1)    return df_sampledef matchIndex(df_geninfo, net):    # Initialize    df_gen = pd.DataFrame()    df_sgen = pd.DataFrame()    df_ext_grid = pd.DataFrame()    # Generators    df_gen['MATPOWER Index'] = net.gen['bus'] + 1    df_gen['PANDAPOWER Index'] = net.gen['bus'].index.to_list()    df_gen['PANDAPOWER Bus Type'] = 'gen'    # Static Generators    df_sgen['MATPOWER Index'] = net.sgen['bus'] + 1    df_sgen['PANDAPOWER Index'] = net.sgen['bus'].index.to_list()    df_sgen['PANDAPOWER Bus Type'] = 'sgen'    # External Grid    df_ext_grid['MATPOWER Index'] = net.ext_grid['bus'] + 1    df_ext_grid['PANDAPOWER Index'] = net.ext_grid['bus'].index.to_list()    df_ext_grid['PANDAPOWER Bus Type'] = 'ext_grid'    # Combine    df_match = pd.concat([df_gen, df_sgen, df_ext_grid])    df_match.reset_index()    # Join    df_geninfo = df_geninfo.merge(df_match, on='MATPOWER Index')    return df_geninfodef waterOPF(ser_exogenous, t, results_labs, net, df_geninfo):    # Initialize    df_geninfo = df_geninfo.copy()    net = copy.deepcopy(net)  # Copy network so not changed later    obj_colnames = ['cp0_eur', 'cp1_eur_per_mw', 'cp2_eur_per_mw2']    idx_colnames = ['element', 'et']    # Create DataFrame of loads    df_load = ser_exogenous[ser_exogenous.index.str.contains('Load')].to_frame('Load (MW)')    df_load['bus'] = df_load.index.str.extract('(\d+)').astype(int).values    df_load.reset_index(inplace=True, drop=True)    # Create DataFrame of cost values    df_cost = net.poly_cost[idx_colnames + obj_colnames]    # Create DataFrame of withdrawal values    df_withdrawal = ser_exogenous[ser_exogenous.index.str.contains('Withdrawal Rate')].to_frame('Withdrawal Rate (Gallon/kWh)')    df_withdrawal['MATPOWER Index'] = df_withdrawal.index.str.extract('(\d+)').astype(int).values    df_withdrawal.reset_index(inplace=True, drop=True)    # Create DataFrame of consumption values    df_consumption = ser_exogenous[ser_exogenous.index.str.contains('Consumption Rate')].to_frame('Consumption Rate (Gallon/kWh)')    df_consumption['MATPOWER Index'] = df_consumption.index.str.extract('(\d+)').astype(int).values    df_consumption.reset_index(inplace=True, drop=True)    # Write objectives information to generator information    df_geninfo[['Cost Term ($)', 'Cost Term ($/MW)', 'Cost Term ($/MW^2)']] = df_geninfo.merge(df_cost, left_on=['PANDAPOWER Index', 'PANDAPOWER Bus Type'], right_on=idx_colnames)[obj_colnames]    df_geninfo['Withdrawal Rate (Gallon/kWh)'] = df_geninfo.merge(df_withdrawal, on='MATPOWER Index')['Withdrawal Rate (Gallon/kWh)']    df_geninfo['Consumption Rate (Gallon/kWh)'] = df_geninfo.merge(df_consumption, on='MATPOWER Index')['Consumption Rate (Gallon/kWh)']    # Convert Units    df_geninfo['Withdrawal Rate (Gallon/MW)'] = df_geninfo['Withdrawal Rate (Gallon/kWh)'] * t  # minutes * hr/minutes * kw/MW    df_geninfo['Consumption Rate (Gallon/MW)'] = df_geninfo['Consumption Rate (Gallon/kWh)'] * t  # minutes * hr/minutes * kw/MW    # Combine and weight objectives    df_geninfo['Weighted Linear Term'] = df_geninfo['Cost Term ($/MW)'] + df_geninfo['Withdrawal Rate (Gallon/MW)'] * ser_exogenous['Withdrawal Weight ($/Gallon)'] + df_geninfo['Consumption Rate (Gallon/MW)'] * ser_exogenous['Consumption Weight ($/Gallon)']    # Assign exogenous parameters to case    net.poly_cost[obj_colnames] = net.poly_cost.merge(df_geninfo, left_on=idx_colnames, right_on=['PANDAPOWER Index', 'PANDAPOWER Bus Type'])[['Cost Term ($)', 'Weighted Linear Term', 'Cost Term ($/MW^2)']]    net.load['p_mw'] = net.load.merge(df_load)['Load (MW)']    # Run DC OPF    try:        pp.rundcopp(net)        state = 'converge'    except:        state = 'not converge'    # Output Depended on State    if state is 'converge':        # Extract internal decisions (power output)        for type in ['gen', 'sgen', 'ext_grid']:            idxs = df_geninfo.index[df_geninfo['PANDAPOWER Bus Type'] == type]            df_geninfo.loc[idxs, 'Power Output (MW)'] = df_geninfo.iloc[idxs, :].merge(net['res_'+type], left_on='PANDAPOWER Index', right_index=True)['p_mw']        # Compute Capacity Ratios        df_geninfo['Ratio of Capacity'] = df_geninfo['Power Output (MW)'] / df_geninfo['MATPOWER Capacity (MW)']        # Compute Objectives        F_gen = (df_geninfo['Cost Term ($)'] + df_geninfo['Power Output (MW)'] * df_geninfo['Cost Term ($/MW)'] + df_geninfo['Power Output (MW)']**2 * df_geninfo['Cost Term ($/MW^2)']).sum()        F_with = (df_geninfo['Power Output (MW)'] * df_geninfo['Withdrawal Rate (Gallon/MW)']).sum()        F_con = (df_geninfo['Power Output (MW)'] * df_geninfo['Consumption Rate (Gallon/MW)']).sum()        F_cos = F_gen + ser_exogenous['Withdrawal Weight ($/Gallon)']*F_with + ser_exogenous['Consumption Weight ($/Gallon)']*F_con        internal_decs = df_geninfo['Ratio of Capacity'].to_list()    elif state is 'not converge':        F_cos = F_with = F_con = F_gen = np.nan        internal_decs = [np.nan]*len(df_geninfo)    return pd.Series([F_cos, F_gen, F_with, F_con] + internal_decs, index=results_labs)def getSobil(problem, Y):    # Perform analysis    Si = sobol.analyze(problem, Y, calc_second_order=True, print_to_console=True)    # Convert to Pandas    total_Si, first_Si, second_Si = Si.to_df()    return total_Si, first_Si, second_Sidef MGSA_FirstOrder(Input, Output, ndomain):    '''    input: nsample * nd matrix, where nsample is the number of sample, and nd    is the input dimension    output: nsample * 1 array    ndomain: number of sub-domain the to divide a single input    This algorithm is proposed by me. Please cite the following paper if you use this code.    Li, Chenzhao, and Sankaran Mahadevan. "An efficient modularized sample-based method to estimate the first-order Sobolâ€™index." Reliability Engineering & System Safety (2016).    '''    (nsample, nd) = np.shape(Input);    # convert the input samples into cdf domains    U = np.linspace(0.0, 1.0, num=ndomain + 1)    cdf_input = np.zeros((nsample, nd))    cdf_values = np.linspace(1.0 / nsample, 1.0, nsample)    j = 1    for i in range(nd):        IX = np.argsort(Input[:, i])        IX2 = np.argsort(IX)        cdf_input[:, i] = cdf_values[IX2]    # compute the first-order indices    VY = np.var(Output, ddof=1)    VarY_local = np.zeros((ndomain, nd))    for i in range(nd):        cdf_input_i = cdf_input[:, i]        output_i = Output        U_i = U        for j in range(ndomain):            sub = cdf_input_i < U_i[j + 1]            VarY_local[j, i] = np.var(output_i[sub], ddof=1)            inverse_sub = ~sub            cdf_input_i = cdf_input_i[inverse_sub]            output_i = output_i[inverse_sub]    index = 1.0 - np.mean(VarY_local, axis=0) / VY    return indexdef main():    # Initialize    df_geninfo, df_operation, df_bounds, net = initialize()    exogenous_labs = ['Withdrawal Weight ($/Gallon)', 'Consumption Weight ($/Gallon)'] + \                     ('MATPOWER Generator ' + df_geninfo['MATPOWER Index'].astype(str) + ' Withdrawal Rate (Gallon/kWh)').tolist() + \                     ('MATPOWER Generator ' + df_geninfo['MATPOWER Index'].astype(str) + ' Consumption Rate (Gallon/kWh)').tolist() + \                     ('PANDAPOWER Bus ' + net.load['bus'].astype(str) + ' Load (MW)').tolist()    results_labs = ['Total Cost ($)', 'Generator Cost ($)', 'Water Withdrawal (Gallon)', 'Water Consumption (Gallon)'] + \                   ('MATPOWER Generator ' + df_geninfo['MATPOWER Index'].astype(str) + ' Ratio of Capacity').to_list()    t = 5 * 1 / 60 * 1000  # minutes * hr/minutes * kw/MW    N = 1024  # for saltelli sampling 1024    print('Success: Initialized')    # Loop over operational scenarios    #df_operation = df_operation.iloc[[0, 1]].reset_index()    for index, row in df_operation.iterrows():        # Define Paths        pathto_sample_output = os.path.join(pathto_data, 'output', 'sample', row['Operational Scenario']+'_results.csv')        pathto_sobil_output = os.path.join(pathto_data, 'output', 'sobil', row['Operational Scenario']+'_results.csv')        # # Define Problem        # problem = {        #     'num_vars': df_bounds.__len__(),        #     'names': df_bounds['Input Factor'].values.tolist(),        #     'bounds': df_bounds[['Min', 'Max']].values.tolist()        # }        # # Generate Samples        # samples = saltelli.sample(problem, N)        # # Apply Coefficients to Exogenous Parameters        # df_sample = getExogenous(samples, df_bounds, row['Withdrawal Weight ($/Gallon)'], row['Consumption Weight ($/Gallon)'], row['Uniform Loading Factor'], df_geninfo, net, exogenous_labs)        # print('Number of Samples: ', len(df_sample))        # print('Success: Exogenous Parameters Computed')        # # Evaluate Model        # ddf_sample = dd.from_pandas(df_sample, npartitions=n_tasks)        # df_results = ddf_sample.apply(lambda row: waterOPF(row[exogenous_labs], t, results_labs, net, df_geninfo), axis=1, meta={key: 'float64' for key in results_labs}).compute(scheduler='processes')        # # df_results = df_sample.apply(lambda row: waterOPF(row[exogenous_labs], t, results_labs, net, df_geninfo), axis=1)        # df_sample_master = pd.concat([df_results, df_sample], axis=1)        # df_sample_master.to_csv(pathto_sample_output, index=False)        # print('Success: Grid Sampled')        df_sample_master = pd.read_csv(pathto_sample_output)        df_sobil_results = pd.DataFrame()        for i in results_labs[0:4]:            a = 1            MGSA_FirstOrder(Input=df_sample_master[                ['C water coal OC', 'C water coal RI', 'C water coal RC', 'C water ng RI', 'C water nuclear RC']].values,                            Output=df_sample_master[i].values, ndomain=int(np.sqrt(df_sample_master.__len__())))            #total_Si, first_Si, second_Si = getSobil(problem, df_results[i].values)            #ser_first = first_Si['S1']            #ser_first.name = i            #df_sobil_results = df_sobil_results.append(ser_first)        df_sobil_results.to_csv(pathto_sobil_output)        print('Success: Sobil Analysis')    return 0if __name__ == '__main__':    multiprocessing.freeze_support()    ProgressBar().register()    main()